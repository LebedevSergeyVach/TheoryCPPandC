#include <stdio.h>
#include <string.h>

#define len_array 5

// Функция, выводящая содержание массивы в консоль
void printArray(int arr[], int size);
// Функция, копирующая данные одного массива в другой (куда, откуда, сколько элементов)
void arr_copy(int *dst, int *src, int n);

// Строка - это массив символов, оканчивающихся символом '\0'

// Функции для подсчет длины строки
int my_strlen1(char str[]);
// Функции для подсчет длины строки с использованием указателей вместо индексов
int my_strlen2(char str[]);

/* Массивы */
int main()
{
    // Способы инициализации массива
    int a3[7];                                  // или "мусор" (локальный), или нули (глобальный, static)
    int a1[3] = {12, -6, 44};                   // a1[0] = 12, a1[1] = -6, a1[2] = 44;
    int a2[3] = {12, -6};                       // a2[0] = 12, a2[1] = -6, a2[2] = 0; оставшиеся нули
    int a4[8] = {0};                            // все элементы нули
    int a5[8] = {};                             // все элементы нули
    int a6[] = {12, -6, 44};                    // int a6[3] = {12, -6, 44};
    int a7[100] = {[77] = 6, [8] = 11};         // a7[77]=6, a7[8]=11, остальные нули
    int a8[100] = {[16 ... 18] = 6, [33] = 11}; // a8[16]=6, a8[17]=6, a8[18]=6, a8[33]=11, остальные нули

    // Инициализация массивы с указанием типа данных и длины
    int a[len_array];

    int *p2;    // указатель (никуда не указывает)
    p2 = &a[2]; // p2 указывает на a[2]

    printf("Pointer  p2 to the 3rd element of the array a[2] -> %p \n", p2); // проверим адреса

    /*
        Оператор sizeof дает размер переменной или типа в байтах. int = 4 байта

        size_t -> беззнаковый целый тип, используется для представления размеров объектов в памяти (Размер зависит от платформы)
    */
    size_t n = sizeof(a); // 20 = 4(int) * 5(количетсво), если sizeof(int) равен 4

    print("Sizeof for array a[] -> %zd \n", n);

    // Заполнение массива через консоль с помощью цикла for
    for (int i = 0; i < 5; i++)
    {
        scanf("%d", &a[i]);
    }

    // Выведение массива в консоль с помощью цикла for
    for (int i = 0; i < 5; i++)
    {
        printf("%d ", a[i]);
    }

    /*
        Создание массива с использованием динамической памяти можно написать так:
    */
    int n;
    scanf("%d", &n);
    float *a = malloc(n * sizeof(float)); // выделяем динамическую память для размещения массива
    // обращаемся как с обычным массивом, доступ к элементу a[i]
    // ...
    free(a); // когда массив не нужен, освобождаем выделенную память

    /*
        memcpy - копирование массивов
        void *memcpy(void *dest, const void *src, size_t n);

        - dest (destination) - куда копировать
        - src (source) - откуда копировать
        - n - сколько байт копировать

        #include <string.h>

        memcpy нельзя использовать на перекрывающихся участках памяти.

        У меня на компьютере работает, посылаю задачу на проверку - не работает.
        Чтобы не было такой ситуации используйте функцию:

        void *memmove(void *dest, const void *src, size_t n);
        Делает то же самое, что memcpy, но работает для перекрывающихся участков памяти.
    */
    int c[10] = {1, -2, 3, -4, 5, -6, 7, -8, 9, 10};
    int d[10];

    memcpy(b, a, sizeof(a));

    /*
        Выведение длины строки
    */
    char s[10] = {'a', 'b', 'c', '\0'};     // то же самое char s[10] = "abc";
    printf("length = %d\n", my_strlen1(s)); // length = 3

    return 0;
}

/*
    Массив в функцию передается как указатель

    Массив - это много данных. Копировать их при передаче в функцию,
    как копировали структуру, требует много памяти и занимает время.
    Проще передавать указатель на массив. Поэтому массивы не копируются в функцию,
    а передается указатель, то есть адрес и тип одного элемента.
*/

// Функция, выводящая содержание массивы в консоль
void printArray(int arr[], int size)
{
    for (int i = 0; i < size; i++)
    {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

// Функция, копирующая данные одного массива в другой (куда, откуда, сколько элементов) - аналог memcpy
void arr_copy(int *dst, int *src, int n)
{
    for (int i = 0; i < n; i++)
        dst[i] = src[i];
}

// Функции для подсчет длины строки
int my_strlen1(char str[])
{
    int n;
    for (n = 0; str[n] != '\0'; n++)
        ; // подчеркиваем, что мы осознаем, что в цикле тело пустое
    return n;
}

// Функции для подсчет длины строки с использованием указателей вместо индексов
int my_strlen2(char str[])
{
    char *p;
    for (p = str; *p != '\0'; p++)
        ; // подчеркиваем, что мы осознаем, что в цикле тело пустое
    return p - str;
}
