# Документация к директории **[`common`](.)**

## [ERROR](.)

### [error.c](error.c)

#### `void error_check_file_exists(int *program_execution, int argc, char *argv[])`

```C
void error_check_file_exists(int *program_execution, int argc, char *argv[])
{
    for (int i = optind; i < argc; i++) {
        if (access(argv[i], F_OK) == -1) {
            fprintf(stderr, "Файл '%s' не существует или недоступен.\n", argv[i]);
            *program_execution = 1;

            break;
        }
    }
}
```

Предназначена для проверки существования файлов, переданных в качестве аргументов командной строки.

- `access(argv[i], F_OK) == -1`: Функция `access` проверяет, существует ли файл, указанный в `argv[i]`. Если файл не существует или недоступен, `access` вернет `-1`.
- `F_OK`: Это флаг, который указывает `access` проверить только существование файла.

---

## [COMMON](.)

### [common.c](common.c)

#### `void print_line(const char *line, int number, int is_nonblank)`

```C
void print_line(const char *line, int number, int is_nonblank)
{
    // Если строка непустая и флаг нумерации непустых строк установлен
    if (is_nonblank)
    {
        printf("%6d\t", number); // Выводим номер строки
    }
    printf("%s", line); // Выводим саму строку
}
```

#### Аргументы

- **`const char *line`**: Указатель на строку, которую нужно вывести.
- **`int number`**: Номер строки, который нужно вывести (если строка непустая).
- **`int is_nonblank`**: Флаг, указывающий, является ли строка непустой. Если `is_nonblank` равен `1`, то строка непустая и нужно вывести номер строки.

---

```C
void process_file(FILE *file, int flags)
{
    char line[MAX_LINE_LENGTH]; // Буфер для хранения строки
    int line_number = 0;        // Счетчик строк
    int prev_line_empty = 0;    // Флаг, указывающий, была ли предыдущая строка пустой

    // Читаем файл построчно
    while (fgets(line, MAX_LINE_LENGTH, file))
    {
        int is_nonblank = (line[0] != '\n'); // Проверяем, является ли строка непустой
        int is_empty = (line[0] == '\n');    // Проверяем, является ли строка пустой

        // Обработка флага -s (сжатие смежных пустых строк)
        if (flags & 0x08)
        {
            if (is_empty)
            {
                if (prev_line_empty)
                {
                    continue; // Пропускаем строку, если она пустая и предыдущая тоже
                }
                prev_line_empty = 1; // Устанавливаем флаг, что текущая строка пустая
            }
            else
            {
                prev_line_empty = 0; // Сбрасываем флаг, если строка непустая
            }
        }

        // Обработка флага -e (отображение символа конца строки как $)
        if (flags & 0x02)
        {
            if (line[strlen(line) - 1] == '\n')
            {
                line[strlen(line) - 1] = '$'; // Заменяем символ конца строки на $
                strcat(line, "\n");           // Добавляем символ новой строки
            }
        }

        // Обработка флага -t (отображение табов как ^I)
        if (flags & 0x10)
        {
            for (char *p = line; *p; ++p)
            {
                if (*p == '\t')
                {
                    // Сдвигаем оставшуюся часть строки вправо на два символа
                    memmove(p + 2, p + 1, strlen(p + 1) + 1);
                    *p = '^'; // Заменяем таб на ^
                    *(++p) = 'I'; // Добавляем I
                }
                // Проверка на четыре пробела подряд
                else if (*p == ' ' && *(p + 1) == ' ' && *(p + 2) == ' ' && *(p + 3) == ' ')
                {
                    // Сдвигаем оставшуюся часть строки вправо на два символа
                    memmove(p + 2, p + 4, strlen(p + 4) + 1);
                    *p = '^'; // Заменяем пробелы на ^
                    *(++p) = 'I'; // Добавляем I
                }
            }
        }

        // Обработка флага -b (нумерация только непустых строк)
        if (flags & 0x01)
        {
            if (is_nonblank)
            {
                print_line(line, ++line_number, 1);
            }
            else
            {
                print_line(line, 0, 0);
            }
        }
        // Обработка флага -n (нумерация всех строк)
        else if (flags & 0x04)
        {
            print_line(line, ++line_number, 1);
        }
        // Без флагов нумерации
        else
        {
            print_line(line, 0, 0);
        }
    }
}
```

#### Аргументы

- **`FILE *file`**: Указатель на файл, который нужно обработать.
- **`int flags`**: Битовый флаг, указывающий, какие опции были переданы в программу.

#### Цикл чтения файла `fgets`

```C
char *fgets(char *str, int n, FILE *stream);
```

- **`str`**: Указатель на буфер, в который будет записана прочитанная строка.
- **`n`**: Максимальное количество символов, которые будут прочитаны (включая завершающий нулевой символ).
- **`stream`**: Указатель на файл, из которого будет производиться чтение.

Используется для чтения файла построчно до тех пор, пока не будет достигнут конец файла (EOF).

---

#### Аргументы функции

- **`FILE *file`**: Указатель на файл, который нужно обработать.
- **`int flags`**: Битовый флаг, указывающий, какие опции были переданы в программу.

#### Логика работы

1. **Инициализация переменных**:
   - `char line[MAX_LINE_LENGTH];`: Буфер для хранения строки.
   - `int line_number = 0;`: Счетчик строк.
   - `int prev_line_empty = 0;`: Флаг, указывающий, была ли предыдущая строка пустой.

2. **Чтение файла построчно**:
   - `while (fgets(line, MAX_LINE_LENGTH, file))`: Читаем файл построчно с помощью функции `fgets`.

3. **Проверка строки**:
   - `int is_nonblank = (line[0] != '\n');`: Проверяем, является ли строка непустой.
   - `int is_empty = (line[0] == '\n');`: Проверяем, является ли строка пустой.

4. **Обработка флага `-b` (нумерация только непустых строк)**:
   - Если флаг `-b` установлен (`flags & 0x01`), то нумеруем только непустые строки.
   - Если строка непустая (`is_nonblank`), вызываем `print_line` с номером строки.
   - Если строка пустая, вызываем `print_line` без номера.

5. **Обработка флага `-n` (нумерация всех строк)**:
   - Если флаг `-n` установлен (`flags & 0x04`), то нумеруем все строки.
   - Вызываем `print_line` с номером строки для каждой строки.

6. **Обработка флага `-s` (сжатие смежных пустых строк)**:
   - Если флаг `-s` установлен (`flags & 0x08`), то сжимаем смежные пустые строки.
   - Если текущая строка пустая и предыдущая строка тоже была пустой (`is_empty && prev_line_empty`), пропускаем строку (`continue`).
   - Обновляем флаг `prev_line_empty`.

7. **Обработка флага `-e` (отображение символа конца строки как $)**:
   - Если флаг `-e` установлен (`flags & 0x02`), то заменяем символ конца строки на `$`.
   - Если последний символ строки — символ новой строки (`\n`), заменяем его на `$` и добавляем символ новой строки.

8. **Обработка флага `-t` (отображение табов как ^I)**:
   - Если флаг `-t` установлен (`flags & 0x10`), то заменяем табы на `^I`.
   - Проходим по строке и заменяем каждый таб (`\t`) на `^I`.

### Заключение

Функция `process_file` обрабатывает файл построчно, применяя различные флаги для изменения вывода. Функция `print_line` используется для вывода строк с учетом нумерации. Код организован так, чтобы легко добавлять новые флаги и изменять поведение программы.





Конечно! Давайте разберем, как работает цикл `while (fgets(line, MAX_LINE_LENGTH, file))`, который используется для чтения файла построчно.

### Функция `fgets`

Функция `fgets` используется для чтения строки из файла. Она имеет следующий прототип:

```c
char *fgets(char *str, int n, FILE *stream);
```

- **`str`**: Указатель на буфер, в который будет записана прочитанная строка.
- **`n`**: Максимальное количество символов, которые будут прочитаны (включая завершающий нулевой символ).
- **`stream`**: Указатель на файл, из которого будет производиться чтение.

### Цикл `while (fgets(line, MAX_LINE_LENGTH, file))`

Цикл `while (fgets(line, MAX_LINE_LENGTH, file))` используется для чтения файла построчно до тех пор, пока не будет достигнут конец файла (EOF).

#### Логика работы цикла

1. **Инициализация**:
   - `char line[MAX_LINE_LENGTH];`: Объявляется буфер `line`, в который будет записываться прочитанная строка.
   - `FILE *file`: Указатель на файл, из которого будет производиться чтение.

2. **Выполнение цикла**:
   - `fgets(line, MAX_LINE_LENGTH, file)`: Вызывается функция `fgets`, которая читает строку из файла и записывает ее в буфер `line`.
   - **Условие цикла**: Если `fgets` успешно прочитала строку (т.е. не достигнут конец файла), она возвращает указатель на буфер `line`. В этом случае условие цикла истинно, и тело цикла выполняется.
   - **Тело цикла**: Внутри тела цикла выполняются операции над прочитанной строкой (например, обработка флагов, вывод строки и т.д.).

3. **Завершение цикла**:
   - Если `fgets` достигает конца файла (EOF) или возникает ошибка, она возвращает `NULL`. В этом случае условие цикла становится ложным, и цикл завершается.

### Пример использования

Рассмотрим пример, где цикл используется для чтения файла и вывода его содержимого построчно:

```c
#include <stdio.h>

#define MAX_LINE_LENGTH 1024

int main() {
    FILE *file = fopen("example.txt", "r");
    if (file == NULL) {
        perror("fopen");
        return 1;
    }

    char line[MAX_LINE_LENGTH];
    while (fgets(line, MAX_LINE_LENGTH, file)) {
        printf("%s", line);
    }

    fclose(file);
    return 0;
}
```

#### Пошаговое выполнение

1. **Открытие файла**:
   - `FILE *file = fopen("example.txt", "r");`: Открывает файл `example.txt` для чтения.

2. **Проверка ошибок**:
   - `if (file == NULL) { ... }`: Проверяет, успешно ли открыт файл. Если нет, выводит сообщение об ошибке и завершает программу.

3. **Чтение файла построчно**:
   - `while (fgets(line, MAX_LINE_LENGTH, file)) { ... }`: Начинает цикл чтения файла построчно.
   - `printf("%s", line);`: Выводит прочитанную строку на экран.

4. **Закрытие файла**:
   - `fclose(file);`: Закрывает файл после завершения чтения.

### Заключение

Цикл `while (fgets(line, MAX_LINE_LENGTH, file))` используется для чтения файла построчно до тех пор, пока не будет достигнут конец файла. Функция `fgets` читает строку из файла и записывает ее в буфер `line`. Если чтение прошло успешно, тело цикла выполняется, и операции над прочитанной строкой производятся. Если достигнут конец файла или возникла ошибка, цикл завершается.