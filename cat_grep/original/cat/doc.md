# Документация к директории **[`cat`](.)**

<a name="up"></a>

## [CAT](.)

### Опции `cat`

| № | Опции | Описание |
| ------ | ------ | ------ |
| 1 | -b (GNU: --number-nonblank) | нумерует только непустые строки |
| 2 | -e предполагает и -v (GNU only: -E то же самое, но без применения -v) | также отображает символы конца строки как $  |
| 3 | -n (GNU: --number) | нумерует все выходные строки |
| 4 | -s (GNU: --squeeze-blank) | сжимает несколько смежных пустых строк |
| 5 | -t предполагает и -v (GNU: -T то же самое, но без применения -v) | также отображает табы как ^I |

### [s21_flags_cat.h](s21_flags_cat.h)

```C
// Определение флагов для команды cat
#define FLAG_B 0x01 // Нумерация только непустых строк 0000 0001
#define FLAG_E 0x02 // Отображение символа конца строки как $ 0000 0010
#define FLAG_N 0x04 // Нумерация всех строк 0000 0100
#define FLAG_S 0x08 // Сжатие смежных пустых строк 0000 1000
#define FLAG_T 0x10 // Отображение табов как ^I 0001 0000
```

#### Битовые операции

Каждый флаг представляет собой уникальный бит в целом числе. Нужно для комбинации флагов с помощью битовых операций. (16CC)
Они представляют собой степени двойки в шестнадцатеричной системе счисления.
В двоичной системе это означает, что каждое значение имеет только один бит, установленный в 1, а остальные биты — в 0.

Подробно про битовые операции и битовые маски **[bit_operations.md](../common/bit_operations.md)**.

---

### [s21_options_cat.c](s21_options_cat.c)

#### `void parse_options(int argc, char * argv[], int * flags)`

```C
/**
 * Парсит аргументы командной строки и устанавливает соответствующие флаги.
 *
 * @param argc              Количество аргументов командной строки.
 * @param argv              Массив аргументов командной строки.
 * @param flags             Указатель на битовую маску флагов, которые будут
 * установлены в зависимости от аргументов.
 *
 * @return int              Возвращает статус выполнения программы (0 - успешно,
 * ненулевое значение - ошибка).
 */
int parse_options(int argc, char *argv[], int *flags)
{
    int program_execution = 0;

    // Определение длинных опций
    static struct option long_options[] = {
        {"number-nonblank", no_argument, 0, 'b'}, // Нумерация только непустых строк
        {"number", no_argument, 0, 'n'},          // Нумерация всех строк
        {"squeeze-blank", no_argument, 0, 's'},   // Сжатие смежных пустых строк
        {0, 0, 0, 0}};

    int flag;

    while ((flag = getopt_long(argc, argv, "benstET", long_options, NULL)) != -1)
    {
        switch (flag)
        {
        case 'b':
            *flags |= FLAG_B; // Установка флага нумерации только непустых строк
            break;
        case 'e':
            *flags |= FLAG_E; // Установка флага отображения символа конца строки как $
            break;
        case 'n':
            *flags |= FLAG_N; // Установка флага нумерации всех строк
            break;
        case 's':
            *flags |= FLAG_S; // Установка флага сжатия смежных пустых строк
            break;
        case 't':
            *flags |= FLAG_T; // Установка флага отображения табов как ^I
            break;
        case 'E':
            *flags |= FLAG_E; // Установка флага отображения символа конца строки как $
            break;
        case 'T':
            *flags |= FLAG_T; // Установка флага отображения табов как ^I
            break;
        default:
            error_used_command(&program_execution, argv[0]);
            break;
        }
    }

    return program_execution;
}
```

#### Аргументы функции `parse_options`

- `int argc`: Количество аргументов, переданных программе.
- `char *argv[]`: Массив строк, содержащий аргументы командной строки.
- `int *flags`: Указатель на переменную, которая будет содержать флаги, соответствующие различным опциям.

#### Возвращаемое значение функции `parse_options`

- `int program_execution`: Состояние выполнения программы (0 - успешно, 1 - ошибка).

#### Описание функции `parse_options`

Функция `parse_options` предназначена для разбора аргументов командной строки и установки соответствующих флагов.
Она использует функцию `getopt_long` для обработки длинных и коротких опций, устанавливая флаги в зависимости от переданных аргументов.
Если обнаружена ошибка в использовании команды, функция вызывает функцию `error_used_command_cat` и возвращает состояние выполнения программы.

---

#### `struct option`

```C
struct option {
    const char *name;     // Имя длинной опции
    int         has_arg;  // Флаг, указывающий, требуется ли аргумент для этой опции
    int        *flag;     // Указатель на переменную, в которую будет записано значение, если flag не равен NULL
    int         val;      // Значение, которое будет возвращено или записано в *flag
};
```

```C
static struct option long_options[] = {
    {"number-nonblank", no_argument, 0, 'b'},
    {"number", no_argument, 0, 'n'},
    {"squeeze-blank", no_argument, 0, 's'},
    {0, 0, 0, 0}};
```

- **name**: Имя длинной опции. `"number-nonblank"`.
- **has_arg**: Флаг, указывающий, требуется ли аргумент для этой опции. Возможные значения:
  - `no_argument` (или 0): Опция не требует аргумента.
  - `required_argument` (или 1): Опция требует обязательного аргумента.
  - `optional_argument` (или 2): Опция может иметь необязательный аргумент.
- **flag**: Указатель на переменную, в которую будет записано значение, если `flag` не равен `NULL`. Если `flag` равен `NULL`, то функция вернет значение `val`.
- **val**: Значение, которое будет возвращено или записано в `*flag`.

`{0, 0, 0, 0}`: Завершающий элемент, указывающий на конец массива опций.

---

#### `getopt_long`

```C
int getopt_long(int argc, char *const argv[], const char *shortopts, const struct option *longopts, int *longindex);
```

- **argc**: Количество аргументов, переданных в `main`.
- **argv**: Массив аргументов, переданных в `main`.
- **shortopts**: Строка, содержащая короткие опции. Например, `"benstET"`.
- **longopts**: Массив структур `struct option`, описывающих длинные опции.
- **longindex**: Указатель на переменную, в которую будет записан индекс найденной длинной опции. Если не нужен, можно передать `NULL`.

---

Битовая операция |=
Оператор |= (битовое ИЛИ с присваиванием) используется для установки определенного бита в переменной flags.

---

### [s21_process_cat_file.c](s21_process_cat_file.c)

#### `void print_char(unsigned char uc, int flags, int *line_number, int *in_nonblank_line, int *new_line_start)`

```C
/**
 * Выводит один символ с учетом установленных флагов.
 *
 * @param uc                Символ для вывода.
 * @param flags             Битовая маска флагов, определяющая режимы вывода.
 * @param line_number       Указатель на номер текущей строки (-n и -b).
 * @param in_nonblank_line  Указатель на флаг, непустая строка (-b).
 * @param new_line_start    Указатель на флаг, начало новой строи (-n).
 *
 * @return void
 */
void print_char(unsigned char uc, int flags, int *line_number, int *in_nonblank_line, int *new_line_start)
{
    // Флаг, указывающий, был ли уже выведен символ
    int printed = 0;

    // Флаг -b: нумерация только не пустых строк
    if (flags & FLAG_B)
    {
        if (uc == '\n')
        {
            // Сбрасываем флаг, если строка пустая
            *in_nonblank_line = 0;
        }
        else if (!*in_nonblank_line)
        {
            // Устанавливаем флаг, если строка непустая
            *in_nonblank_line = 1;
            printf("%6d\t", ++(*line_number));
        }
    }
    // Флаг -n: нумерация всех строк
    else if (flags & FLAG_N)
    {
        if (*new_line_start)
        {
            printf("%6d\t", ++(*line_number));
            // Сбрасываем флаг начала новой строки
            *new_line_start = 0;
        }
        if (uc == '\n')
        {
            // Устанавливаем флаг начала новой строки
            *new_line_start = 1;
        }
    }

    // Флаг -E: отображение символа конца строки как $
    if (flags & FLAG_E && uc == '\n')
    {
        printf("$");
    }

    // Флаг -T: отображение символа табуляции как ^I
    if (flags & FLAG_T && uc == '\t')
    {
        printf("^I");
        // Устанавливаем флаг, что символ был выведен
        printed = 1;
    }

    // Флаг -V: отображение непечатаемого символа
    if (flags & FLAG_V && !printed)
    {
        if (uc < 32 && uc != '\t' && uc != '\n')
        {
            // Вывод символа в виде ^X
            printf("^%c", uc + 64);
            // Устанавливаем флаг, что символ был выведен
            printed = 1;
        }
        else if (uc == 127)
        {
            // Вывод символа DEL в виде ^?
            printf("^?");
            // Устанавливаем флаг, что символ был выведен
            printed = 1;
        }
        else if (uc > 127)
        {
            unsigned char high_byte = uc - 128;
            if (high_byte < 32 && high_byte != '\t' && high_byte != '\n')
            {
                // Вывож символа в виде M-^X
                printf("M-^%c", high_byte + 64);
            }
            else
            {
                // Вывож символа в виде M-X
                printf("M-%c", high_byte);
            }

            // Устанавливаем флаг, что символ был выведен
            printed = 1;
        }
    }

    // Вывод текущего символа, если он еще не был выведен
    if (!printed)
    {
        putchar(uc);
    }
}
```

#### Аргументы функции `print_char`

- **`uc`**: Символ для вывода.
- **`flags`**: Битовая маска флагов, определяющая режимы вывода.
- **`line_number`**: Указатель на номер текущей строки (используется для флага `-n` и `-b`).
- **`in_nonblank_line`**: Указатель на флаг, указывающий, находимся ли мы в непустой строке (используется для флага `-b`).
- **`new_line_start`**: Указатель на флаг, указывающий, является ли текущий символ началом новой строки (используется для флага `-n`).

#### Описание функции `print_char`

Выводит один символ с учетом установленных флагов. Обрабатывает флаги `-b`, `-n`, `-E`, `-T`, и `-V`.

---

#### `void process_file(FILE *file, int flags)`

```C
/**
 * Обрабатывает файл и выводит его содержимое с учетом установленных флагов.
 *
 * @param file              Указатель на файл для обработки.
 * @param flags             Битовая маска флагов, определяющая режимы вывода.
 *
 * @return void
 */
void process_file_cat(FILE *file, int flags)
{
    int c;

    int line_number = 0;      // Номер текущей строки
    int prev_line_empty = 0;  // Флаг, указывающий, была ли предыдущая строка пустой
    int in_nonblank_line = 0; // Флаг, указывающий, находимся ли мы в непустой строке
    int skip_newline = 0;     // Флаг, указывающий, нужно ли пропустить перевод строки
    int new_line_start = 1;   // Флаг, указывающий, является ли текущий символ началом новой строки

    while ((c = fgetc(file)) != EOF)
    {
        unsigned char uc = (unsigned char)c;

        // Флаг -s: сжимает несколько смежных пустых строк в одну
        if (flags & FLAG_S)
        {
            if (uc == '\n')
            {
                if (prev_line_empty)
                {
                    // Пропуск перевода строки, если предыдущая строка была пустой
                    skip_newline = 1;
                    continue;
                }

                // Установка флаг, что текущая строка пустая
                prev_line_empty = 1;
            }
            else
            {
                if (skip_newline)
                {
                    // Флаг -E: отображае символа конца строки как $
                    if (flags & FLAG_E)
                    {
                        putchar('$');
                    }

                    // Вывод перевода строки
                    putchar('\n');
                    // Сброс флага пропуска перевода строки
                    skip_newline = 0;
                }

                // Сброс флага, что строка пустая
                prev_line_empty = 0;
            }
        }

        // Вывод текущего символа с учетом флагов
        print_char(uc, flags, &line_number, &in_nonblank_line, &new_line_start);
    }
}
```

#### Аргументы функции `process_file_cat`

- `FILE *file`: Указатель на файл, который нужно обработать.
- `int flags`: Битовый флаг, указывающий, какие опции были переданы в программу.

#### Описание функции `process_file_cat`

Обрабатывает файл и выводит его содержимое с учетом установленных флагов.
Обрабатывает флаг `-s` для сжатия пустых строк и вызывает функцию `print_char` для вывода каждого символа.

- **`FLAG_S`**: Сжимает последовательные пустые строки.
- **`FLAG_E`**: Добавляет символ `$` в конце каждой строки.
- **`FLAG_T`**: Преобразует символы табуляции в `^I`.
- **`FLAG_V`**: Преобразует непечатаемые символы в их эквиваленты с `^` или `M-`.
- **`FLAG_B`**: Нумерует только непустые строки.
- **`FLAG_N`**: Нумерует все строки.

---

#### Цикл чтения файла `fgets`

```C
char *fgets(char *str, int n, FILE *stream);
```

- **`str`**: Указатель на буфер, в который будет записана прочитанная строка.
- **`n`**: Максимальное количество символов, которые будут прочитаны (включая завершающий нулевой символ).
- **`stream`**: Указатель на файл, из которого будет производиться чтение.

Используется для чтения файла построчно до тех пор, пока не будет достигнут конец файла (EOF).

---

#### [doc.md](doc.md) [UP](#up)
