# Документация к директории **[grep](doc.md)**

<a name="up"></a>

## [GREP](.)

### Опции `grep`

| № | Опции | Описание |
| ------ | ------ | ------ |
| 1 | -e | Шаблон. |
| 2 | -i | Игнорирует различия регистра.  |
| 3 | -v | Инвертирует смысл поиска соответствий. |
| 4 | -c | Выводит только количество совпадающих строк. |
| 5 | -l | Выводит только совпадающие файлы.  |
| 6 | -n | Предваряет каждую строку вывода номером строки из файла ввода. |
| 7 | -h | Выводит совпадающие строки, не предваряя их именами файлов. |
| 8 | -s | Подавляет сообщения об ошибках о несуществующих или нечитаемых файлах. |
| 9 | -f file | Получает регулярные выражения из файла. |
| 10 | -o | Печатает только совпадающие (непустые) части совпавшей строки. |

### [s21_flags_grep.h](s21_flags_grep.h)

```C
// Определение флагов для опций команды grep
#define FLAG_E 0x01 // Регулярное выражение 0000 0001
#define FLAG_I 0x02 // Игнорирование регистра 0000 0010
#define FLAG_V 0x04 // Инвертирование совпадений 0000 0100
#define FLAG_C 0x08 // Подсчет количества совпадений 0000 1000
#define FLAG_L 0x10 // Вывод только имен файлов с совпадениями 0001 0000
#define FLAG_N 0x20 // Вывод номеров строк 0010 0000
#define FLAG_F 0x40 // Использование шаблонов из файла 0100 0000
#define FLAG_H 0x80  // Не выводит имена файлов перед совпадениями 1000 0000
```

#### Битовые операции

Каждый флаг представляет собой уникальный бит в целом числе. Нужно для комбинации флагов с помощью битовых операций. (16CC)
Они представляют собой степени двойки в шестнадцатеричной системе счисления.
В двоичной системе это означает, что каждое значение имеет только один бит, установленный в 1, а остальные биты — в 0.

- `0x01` (десятичное 1) — 0000 0001
- `0x02` (десятичное 2) — 0000 0010
- `0x04` (десятичное 4) — 0000 0100
- `0x08` (десятичное 8) — 0000 1000
- `0x10` (десятичное 16) — 0001 0000
- `0x20` (десятичное 32) — 0010 0000
- `0x40` (десятичное 64) — 0100 0000
- `0x80` (десятичное 128) - 1000 0000

Каждый флаг занимает свой уникальный бит в переменной, что позволяет хранить несколько флагов в одной переменной типа int.

#### Установка флага `(|=)`

Операция `|=` (битовое ИЛИ с присваиванием) используется для установки флага в переменной.

```C
int flags = 0;  // Изначально все флаги сброшены
flags |= FLAG_E;  // Установка флага FLAG_E
```

В двоичном виде:

```C
flags = 0000 0000
FLAG_E = 0000 0001
flags |= FLAG_E  ->  flags = 0000 0001
```

#### Проверка флага `(&)`

Операция `&` (битовое И) используется для проверки, установлен ли определенный флаг.

```C
if (flags & FLAG_E) {
    // Флаг FLAG_E установлен
}
```

В двоичном виде:

```C
flags = 0000 0001
FLAG_E = 0000 0001
flags & FLAG_E  ->  0000 0001 (ненулевое значение, флаг установлен)
```

#### Сброс флага `(&= ~)`

Операция `&= ~` (битовое И с инверсией) используется для сброса флага.

```C
flags &= ~FLAG_E;  // Сьрасывает флаг FLAG_E
```

В двоичном виде:

```C
flags = 0000 0001
~FLAG_E = 1111 1110
flags &= ~FLAG_E  ->  flags = 0000 0000
```

---

### [s21_options_grep.c](s21_options_grep.c)

#### `int parse_options(int argc, char *argv[], int *flags, char **pattern, int *program_execution)`

```C
int parse_options(int argc, char *argv[], int *flags, char **pattern, int *program_execution)
{
    // Определение длинных опций для getopt_long
    static struct option long_options[] = {
        {"regexp", required_argument, 0, 'e'},       // Опция -e с обязательным аргументом
        {"ignore-case", no_argument, 0, 'i'},        // Опция -i без аргумента
        {"invert-match", no_argument, 0, 'v'},       // Опция -v без аргумента
        {"count", no_argument, 0, 'c'},              // Опция -c без аргумента
        {"files-with-matches", no_argument, 0, 'l'}, // Опция -l без аргумента
        {"line-number", no_argument, 0, 'n'},        // Опция -n без аргумента
        {"file", required_argument, 0, 'f'},         // Опция -f с обязательным аргументом
        {0, 0, 0, 0}                                 // Завершающий элемент
    };

    // Инициализация указателя на шаблон
    *pattern = NULL;

    // Переменная для хранения текущей опции
    int opt;

    // Цикл для парсинга опций командной строки
    while ((opt = getopt_long(argc, argv, "e:ivclnf", long_options, NULL)) != -1)
    {
        switch (opt)
        {
        case 'e':
            *flags |= FLAG_E;  // Установка флага FLAG_E
            *pattern = optarg; // Сохранение шаблона из аргумента опции
            break;
        case 'i':
            *flags |= FLAG_I; // Установка флага FLAG_I
            break;
        case 'v':
            *flags |= FLAG_V; // Установка флага FLAG_V
            break;
        case 'c':
            *flags |= FLAG_C; // Установка флага FLAG_C
            break;
        case 'l':
            *flags |= FLAG_L; // Установка флага FLAG_L
            break;
        case 'n':
            *flags |= FLAG_N; // Установка флага FLAG_N
            break;
        case 'f':
            *flags |= FLAG_F; // Установка флага FLAG_F
            read_patterns_from_file(optarg, pattern, program_execution); // Чтение шаблонов из переданного файла
            break;
        default:
            error_used_command_grep(program_execution, argv[0]); // Вызов функции для обработки ошибки
            break;
        }
    }

    // Если произошла ошибка, сбрасываем индекс опций
    if (*program_execution)
    {
        optind = -1;
    }
    // Если шаблон не был указан с флагом -e, берем первый аргумент после флагов
    else if (*pattern == NULL && optind < argc)
    {
        *pattern = argv[optind++];
    }

    // Возвращаем индекс следующего аргумента после флагов
    return optind;
}
```

#### Аргументы функции `parse_options`

- **`int argc`**: Количество аргументов, переданных программе.
- **`char *argv[]`**: Массив строк, содержащий аргументы командной строки.
- **`int *flags`**: Указатель на переменную, которая будет содержать флаги, соответствующие различным опциям.
- **`char **pattern`**: Указатель на указатель на строку, которая будет содержать шаблон для поиска.
- **`int *program_execution`**: Указатель на переменную, которая указывает на состояние выполнения программы (0 - успешно, 1 - ошибка).

#### Возвращаемое значение функции `parse_options`

- `int optind`: Индекс следующего аргумента, который нужно обработать.

#### Описание функции `parse_options`

Функция `parse_options` предназначена для разбора аргументов командной строки и установки соответствующих флагов и параметров.
Она использует функцию `getopt_long` для обработки длинных и коротких опций, устанавливая флаги и сохраняя шаблон для поиска.
Если шаблон не указан явно, функция попытается использовать следующий аргумент как шаблон.
Возвращает индекс следующего аргумента для дальнейшей обработки.

---

#### `struct option`

```C
struct option {
    const char *name;     // Имя длинной опции
    int         has_arg;  // Флаг, указывающий, требуется ли аргумент для этой опции
    int        *flag;     // Указатель на переменную, в которую будет записано значение, если flag не равен NULL
    int         val;      // Значение, которое будет возвращено или записано в *flag
};
```

```C
static struct option long_options[] = {
    {"regexp", required_argument, 0, 'e'},
    {"ignore-case", no_argument, 0, 'i'},
    {"invert-match", no_argument, 0, 'v'},
    {"count", no_argument, 0, 'c'},
    {"files-with-matches", no_argument, 0, 'l'},
    {"line-number", no_argument, 0, 'n'},
    {"show-filename", no_argument, 0, 't'},
    {0, 0, 0, 0}};
```

- **name**: Имя длинной опции. `"number-nonblank"`.
- **has_arg**: Флаг, указывающий, требуется ли аргумент для этой опции. Возможные значения:
  - `no_argument` (или 0): Опция не требует аргумента.
  - `required_argument` (или 1): Опция требует обязательного аргумента.
  - `optional_argument` (или 2): Опция может иметь необязательный аргумент.
- **flag**: Указатель на переменную, в которую будет записано значение, если `flag` не равен `NULL`. Если `flag` равен `NULL`, то функция вернет значение `val`.
- **val**: Значение, которое будет возвращено или записано в `*flag`.

`{0, 0, 0, 0}`: Завершающий элемент, указывающий на конец массива опций.

---

#### `getopt_long`

```C
int getopt_long(int argc, char *const argv[], const char *shortopts, const struct option *longopts, int *longindex);
```

- **argc**: Количество аргументов, переданных в `main`.
- **argv**: Массив аргументов, переданных в `main`.
- **shortopts**: Строка, содержащая короткие опции. Например, `"benstET"`.
- **longopts**: Массив структур `struct option`, описывающих длинные опции.
- **longindex**: Указатель на переменную, в которую будет записан индекс найденной длинной опции. Если не нужен, можно передать `NULL`.

---

Битовая операция |=
Оператор |= (битовое ИЛИ с присваиванием) используется для установки определенного бита в переменной flags.

---

Возвращает индекс следующего аргумента после флагов

---

### [s21_process_grep_file.c](s21_process_grep_file.c)

#### `void process_file_grep(int flags, const char *pattern, FILE *file, const char *filename, int file_count, int *program_execution)`

```C
void process_file_grep(int flags, const char *pattern, FILE *file, const char *filename, int file_count, int *program_execution)
{
    regex_t regex;

    // Флаги для компиляции регулярного выражения
    int regex_flags = REG_EXTENDED;

    if (flags & FLAG_I)
    {
        // Добавление флага игнорирования регистра, если указан флаг -i
        regex_flags |= REG_ICASE;
    }

    // Компиляция регулярного выражения
    if (regcomp(&regex, pattern, regex_flags) != 0)
    {
        fprintf(stderr, YELLOW "Недопустимое регулярное выражение: " BLUE "%s\n" RESET, pattern);
        *program_execution = 1;
        return;
    }

    char line[MAX_LINE_LENGTH]; // Буфер для хранения строки
    int line_number = 0;        // Счетчик строк
    int match_count = 0;        // Счетчик совпадений
    int file_has_matches = 0;   // Флаг, указывающий, есть ли совпадения в файле

    // Чтение файла построчно
    while (fgets(line, sizeof(line), file))
    {
        line_number++;
        // Проверка совпадения строки с регулярным выражением
        int match = regexec(&regex, line, 0, NULL, 0) == 0;

        if ((flags & FLAG_V) ? !match : match)
        {
            // Инвертирование совпадения, если указан флаг -v
            if (flags & FLAG_L)
            {
                // Установка флага, если найдено совпадение и указан флаг -l
                file_has_matches = 1;
                // Прерывание цикла, так как достаточно найти хотя бы одно совпадение
                break;
            }
            if (flags & FLAG_C)
            {
                // Увеличение счетчика совпадений, если указан флаг -c
                match_count++;
            }
            else
            {
                if (file_count > 1)
                {
                    // Вывод имени файла, если файлов больше одного
                    printf(VIOLET "%s:\t " RESET, file == stdin ? "-" : filename);
                }
                if (flags & FLAG_N)
                {
                    printf(GREEN "%d:\t" RESET, line_number);
                }
                printf(RED "%s" RESET, line);
            }
        }
    }

    // Вывод количества совпадений, если указан флаг -c
    if (flags & FLAG_C)
    {
        if (file_count > 1)
        {
            // Вывод имени файла синим цветом, если файлов больше одного
            printf(VIOLET "%s:\t" RESET, file == stdin ? "-" : filename);
        }

        // Вывод количества совпадений красным цветом
        printf(RED "%d" RESET "\n", match_count);
    }

    // Вывод имени файла, если указан флаг -l и найдены совпадения
    if (flags & FLAG_L && file_has_matches)
    {
        printf(VIOLET "%s" RESET "\n", file == stdin ? "-" : filename);
    }

    // Освобождение ресурсов, занятых регулярным выражением
    regfree(&regex);
}
```

#### Аргументы функции `process_file_grep`

- **`int flags`**: Битовый флаг, указывающий, какие опции были переданы в программу.
- **`const char *pattern`**: Строка, содержащая регулярное выражение для поиска.
- **`FILE *file`**: Указатель на файл, который нужно обработать.
- **`const char *filename`**: Имя файла, который обрабатывается (используется для вывода).
- **`int file_count`**: Количество файлов, переданных в программу.
- **`int *program_execution`**: Указатель на переменную, которая указывает на состояние выполнения программы (0 - успешно, 1 - ошибка).

#### Описание функции `process_file_grep`

Функция `process_file_grep` предназначена для обработки файла с использованием заданного регулярного выражения и флагов.
Она компилирует регулярное выражение с учетом флага `FLAG_I` (игнорирование регистра), затем читает файл построчно и проверяет каждую строку на соответствие шаблону.
В зависимости от флагов, функция выводит соответствующие строки, количество совпадений или имена файлов, содержащих совпадения.
Если возникает ошибка при компиляции регулярного выражения, функция устанавливает флаг `program_execution` в 1 и завершает работу.

- **`FLAG_I`**: Игнорирование регистра при сравнении строк.
- **`FLAG_V`**: Инвертированный поиск (вывод строк, которые не соответствуют шаблону).
- **`FLAG_C`**: Подсчет количества совпадений.
- **`FLAG_L`**: Вывод имен файлов, содержащих совпадения.
- **`FLAG_N`**: Вывод номеров строк вместе с совпадениями.

---

#### Компиляция регулярного выражения REGEX

```C
regex_t regex;

// Флаги для компиляции регулярного выражения
int regex_flags = REG_EXTENDED;

if (flags & FLAG_I)
{
    // Добавление флага игнорирования регистра, если указан флаг -i
    regex_flags |= REG_ICASE;
}
```

- **`regex_t regex;`** — объявление структуры для хранения регулярного выражения.
- **`int regex_flags = REG_EXTENDED;`** — установка флагов для компиляции регулярного выражения.
- **`if (flags & FLAG_I) { regex_flags |= REG_ICASE; }`** — добавление флага игнорирования регистра, если указан флаг `-i`.
- **`regcomp(&regex, pattern, regex_flags)`** — компиляция регулярного выражения. Если компиляция завершается неудачно, выводится сообщение об ошибке и функция завершается.

---

#### Компиляции регулярного выражения в формат для работы с текстом

```C
int regcomp(regex_t *__restrict__ __preg, const char *__restrict__ __pattern, int __cflags)
```

```C
regcomp(&regex, pattern, regex_flags)
```

- **`regex_t preg`**: Указатель на структуру regex_t, которая будет содержать скомпилированное регулярное выражение.
- **`const char`** pattern: Строка, содержащая регулярное выражение, которое нужно скомпилировать.
- **`int cflags`**: Флаги, которые влияют на компиляцию регулярного выражения.

Флаги

- **`REG_EXTENDED`**: Использовать расширенный синтаксис регулярных выражений POSIX.
- **`REG_ICASE`**: Игнорировать регистр символов при сравнении.
- **`REG_NOSUB`**: Не сохранять информацию о совпадениях (полезно для простого поиска совпадений).
- **`REG_NEWLINE`**: Обрабатывать символ новой строки как разделитель строк.

---

#### Цикл чтения файла `fgets`

```C
char *fgets(char *str, int n, FILE *stream);
```

- **`str`**: Указатель на буфер, в который будет записана прочитанная строка.
- **`n`**: Максимальное количество символов, которые будут прочитаны (включая завершающий нулевой символ).
- **`stream`**: Указатель на файл, из которого будет производиться чтение.

Используется для чтения файла построчно до тех пор, пока не будет достигнут конец файла (EOF).

```C
while (fgets(line, sizeof(line), file))
```

---

#### Проверка совпадения строки с регулярным выражением

`regexec` — выполняет поиск совпадений регулярного выражения в строке.

```C
int regexec(const regex_t *preg, const char *string, size_t nmatch, regmatch_t pmatch[], int eflags);
```

- `preg`: Указатель на скомпилированное регулярное выражение.
- `string`: Строка, в которой ищется совпадение.
- `nmatch`: Количество элементов в массиве pmatch. Если nmatch равно 0, то pmatch игнорируется.
- `pmatch`: Массив структур regmatch_t, который будет содержать информацию о совпадениях.
- `eflags`: Дополнительные флаги для поиска.

```C
regexec(&regex, line, 0, NULL, 0) == 0:
```

- `&regex`: Указатель на скомпилированное регулярное выражение.
- `line`: Строка, в которой ищется совпадение.
- `0`: Количество элементов в массиве pmatch. В данном случае, pmatch не используется.
- `NULL`: Указатель на массив pmatch. В данном случае, pmatch не используется.
- `0`: Дополнительные флаги для поиска. В данном случае, флаги не используются.

Функция regexec возвращает 0, если совпадение найдено, и ненулевое значение, если совпадение не найдено.

== 0 проверяет, найдено ли совпадение. Если совпадение найдено, результат будет 1 (истинно), иначе — 0 (ложно).

---

### [s21_read_patterns_from_file.c](s21_read_patterns_from_file.c)

#### `void read_patterns_from_file(const char *filename, char **pattern, int *program_execution)`

```C
// Функция для чтения шаблонов из файла
void read_patterns_from_file(const char *filename, char **pattern, int *program_execution)
{
    // Открытие файла с шаблонами
    FILE *file = fopen(filename, "r");
    if (file == NULL)
    {
        fprintf(stderr, YELLOW "Файла с шаблонами " BLUE "`%s` " YELLOW "не существует или недоступен.\n" RESET, filename);
        *program_execution = 1;
    }

    if (!*program_execution)
    {
        // Инициализация указателя на строку с шаблонами
        *pattern = NULL;
        char line[MAX_LINE_LENGTH];

        // Чтение строки из файла до тех пор, пока не достигнет конца файла
        while (fgets(line, sizeof(line), file))
        {
            size_t len = strlen(line);

            if (line[len - 1] == '\n')
            {
                line[len - 1] = '\0';
            }

            // Первая строка pattern = NULL
            if (*pattern == NULL)
            {
                // Выделение памяти для первой строки ('\0')
                *pattern = malloc(len + 1);

                if (*pattern == NULL)
                {
                    fclose(file);

                    fprintf(stderr, RED "Ошибка выделения памяти для шаблона!\n" RESET);
                    *program_execution = 1;

                    break;
                }

                // Копирование строки в pattern
                strcpy(*pattern, line);
            }
            else
            {
                // pattern уже инициализирован
                // Выделение новой памяи для объединенной строки (pattern + новая строка + "|" + "\0")
                char *new_patterns = realloc(*pattern, strlen(*pattern) + len + 2);

                if (new_patterns == NULL)
                {
                    free(*pattern);
                    fclose(file);

                    fprintf(stderr, RED "Ошибка выделения памяти для шаблона!\n" RESET);
                    *program_execution = 1;

                    break;
                }

                // Обновление указателя на pattern
                *pattern = new_patterns;

                // Добавление разделителя для шаблонов
                strcat(*pattern, "|");

                // Добавление новой строки
                strcat(*pattern, line);
            }
        }

        fclose(file);
    }
}
```

#### Аргументы функции `read_patterns_from_file`

- **`const char *filename`**: Имя файла, из которого будут считываться шаблоны регулярных выражений.
- **`char **pattern`**: Указатель на строку, в которую будет записан результат — объединенные шаблоны.
- **`int *program_execution`**: Указатель на переменную, которая будет установлена в 1 в случае ошибки, чтобы указать на неудачное выполнение программы.

#### Описание функции `read_patterns_from_file`

Предназначена для чтения шаблонов регулярных выражений из указанного файла.
Открывает файл, читает каждую строку, удаляет символ новой строки (если он есть), и сохраняет строку как шаблон.
И объединения их в одну строку, разделенную символом "|".
Это позволяет использовать несколько шаблонов в одном регулярном выражении.

---

#### [doc.md](doc.md) [UP](#up)
