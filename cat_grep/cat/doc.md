# Документация к директории **[`cat`](.)**

## [CAT](.)

### Опции `cat`

| № | Опции | Описание |
| ------ | ------ | ------ |
| 1 | -b (GNU: --number-nonblank) | нумерует только непустые строки |
| 2 | -e предполагает и -v (GNU only: -E то же самое, но без применения -v) | также отображает символы конца строки как $  |
| 3 | -n (GNU: --number) | нумерует все выходные строки |
| 4 | -s (GNU: --squeeze-blank) | сжимает несколько смежных пустых строк |
| 5 | -t предполагает и -v (GNU: -T то же самое, но без применения -v) | также отображает табы как ^I |

### [s21_flags_cat.h](s21_flags_cat.h)

```C
// Определение флагов для опций
#define FLAG_B 0x01 // Нумерация только непустых строк
#define FLAG_E 0x02 // Отображение символа конца строки как $
#define FLAG_N 0x04 // Нумерация всех строк
#define FLAG_S 0x08 // Сжатие смежных пустых строк
#define FLAG_T 0x10 // Отображение табов как ^I
```

Каждый флаг представляет собой уникальный бит в целом числе. Нужно для комбинации флагов с помощью битовых операций. (16CC)

---

### [s21_options_cat.c](s21_options_cat.c)

#### `void parse_options(int argc, char * argv[], int * flags)`

```C
// Функция для парсинга опций командной строки
int parse_options(int argc, char *argv[], int *flags)
{
    int program_execution = 0;

    // Определение длинных опций
    static struct option long_options[] = {
        {"number-nonblank", no_argument, 0, 'b'}, // Нумерация только непустых строк
        {"number", no_argument, 0, 'n'},          // Нумерация всех строк
        {"squeeze-blank", no_argument, 0, 's'},   // Сжатие смежных пустых строк
        {0, 0, 0, 0}};

    int flag;

    while ((flag = getopt_long(argc, argv, "benstET", long_options, NULL)) != -1)
    {
        switch (flag)
        {
        case 'b':
            *flags |= FLAG_B; // Установка флага нумерации только непустых строк
            break;
        case 'e':
            *flags |= FLAG_E; // Установка флага отображения символа конца строки как $
            break;
        case 'n':
            *flags |= FLAG_N; // Установка флага нумерации всех строк
            break;
        case 's':
            *flags |= FLAG_S; // Установка флага сжатия смежных пустых строк
            break;
        case 't':
            *flags |= FLAG_T; // Установка флага отображения табов как ^I
            break;
        case 'E':
            *flags |= FLAG_E; // Установка флага отображения символа конца строки как $
            break;
        case 'T':
            *flags |= FLAG_T; // Установка флага отображения табов как ^I
            break;
        default:
            error_used_command(&program_execution, argv[0]);
            break;
        }
    }

    return program_execution;
}
```

---

#### `struct option`

```C
struct option {
    const char *name;     // Имя длинной опции
    int         has_arg;  // Флаг, указывающий, требуется ли аргумент для этой опции
    int        *flag;     // Указатель на переменную, в которую будет записано значение, если flag не равен NULL
    int         val;      // Значение, которое будет возвращено или записано в *flag
};
```

```C
static struct option long_options[] = {
    {"number-nonblank", no_argument, 0, 'b'},
    {"number", no_argument, 0, 'n'},
    {"squeeze-blank", no_argument, 0, 's'},
    {0, 0, 0, 0}};
```

- **name**: Имя длинной опции. `"number-nonblank"`.
- **has_arg**: Флаг, указывающий, требуется ли аргумент для этой опции. Возможные значения:
  - `no_argument` (или 0): Опция не требует аргумента.
  - `required_argument` (или 1): Опция требует обязательного аргумента.
  - `optional_argument` (или 2): Опция может иметь необязательный аргумент.
- **flag**: Указатель на переменную, в которую будет записано значение, если `flag` не равен `NULL`. Если `flag` равен `NULL`, то функция вернет значение `val`.
- **val**: Значение, которое будет возвращено или записано в `*flag`.

`{0, 0, 0, 0}`: Завершающий элемент, указывающий на конец массива опций.

---

#### `getopt_long`

```C
int getopt_long(int argc, char *const argv[], const char *shortopts, const struct option *longopts, int *longindex);
```

- **argc**: Количество аргументов, переданных в `main`.
- **argv**: Массив аргументов, переданных в `main`.
- **shortopts**: Строка, содержащая короткие опции. Например, `"benstET"`.
- **longopts**: Массив структур `struct option`, описывающих длинные опции.
- **longindex**: Указатель на переменную, в которую будет записан индекс найденной длинной опции. Если не нужен, можно передать `NULL`.

---

Битовая операция |=
Оператор |= (битовое ИЛИ с присваиванием) используется для установки определенного бита в переменной flags.

---

### [s21_process_cat_file.c](s21_process_cat_file.c)

#### `void print_line(const char *line, int number, int is_nonblank)`

```C
// Функция для вывода строки с учетом нумерации
void print_line(const char *line, int number, int is_nonblank)
{
    // Если строка непустая и флаг нумерации непустых строк установлен
    if (is_nonblank)
    {
        printf("%6d\t", number); // Выводим номер строки
    }
    printf("%s", line); // Выводим саму строку
}
```

#### Аргументы

- **`const char *line`**: Указатель на строку, которую нужно вывести.
- **`int number`**: Номер строки, который нужно вывести (если строка непустая).
- **`int is_nonblank`**: Флаг, указывающий, является ли строка непустой. Если `is_nonblank` равен `1`, то строка непустая и нужно вывести номер строки.

---

#### `void process_file(FILE *file, int flags)`

```C
void process_file(FILE *file, int flags)
{
    char line[MAX_LINE_LENGTH]; // Буфер для хранения строки
    int line_number = 0;        // Счетчик строк
    int prev_line_empty = 0;    // Флаг, указывающий, была ли предыдущая строка пустой

    // Читаем файл построчно
    while (fgets(line, MAX_LINE_LENGTH, file))
    {
        int is_nonblank = (line[0] != '\n'); // Проверяем, является ли строка непустой
        int is_empty = (line[0] == '\n');    // Проверяем, является ли строка пустой

        // Обработка флага -s (сжатие смежных пустых строк)
        if (flags & 0x08)
        {
            if (is_empty)
            {
                if (prev_line_empty)
                {
                    continue; // Пропускаем строку, если она пустая и предыдущая тоже
                }
                prev_line_empty = 1; // Устанавливаем флаг, что текущая строка пустая
            }
            else
            {
                prev_line_empty = 0; // Сбрасываем флаг, если строка непустая
            }
        }

        // Обработка флага -e (отображение символа конца строки как $)
        if (flags & 0x02)
        {
            if (line[strlen(line) - 1] == '\n')
            {
                line[strlen(line) - 1] = '$'; // Заменяем символ конца строки на $
                strcat(line, "\n");           // Добавляем символ новой строки
            }
        }

        // Обработка флага -t (отображение табов как ^I)
        if (flags & 0x10)
        {
            for (char *p = line; *p; ++p)
            {
                if (*p == '\t')
                {
                    // Сдвигаем оставшуюся часть строки вправо на два символа
                    memmove(p + 2, p + 1, strlen(p + 1) + 1);
                    *p = '^'; // Заменяем таб на ^
                    *(++p) = 'I'; // Добавляем I
                }
                // Проверка на четыре пробела подряд
                else if (*p == ' ' && *(p + 1) == ' ' && *(p + 2) == ' ' && *(p + 3) == ' ')
                {
                    // Сдвигаем оставшуюся часть строки вправо на два символа
                    memmove(p + 2, p + 4, strlen(p + 4) + 1);
                    *p = '^'; // Заменяем пробелы на ^
                    *(++p) = 'I'; // Добавляем I
                }
            }
        }

        // Обработка флага -b (нумерация только непустых строк)
        if (flags & 0x01)
        {
            if (is_nonblank)
            {
                print_line(line, ++line_number, 1);
            }
            else
            {
                print_line(line, 0, 0);
            }
        }
        // Обработка флага -n (нумерация всех строк)
        else if (flags & 0x04)
        {
            print_line(line, ++line_number, 1);
        }
        // Без флагов нумерации
        else
        {
            print_line(line, 0, 0);
        }
    }
}
```

#### Аргументы функции

- **`FILE *file`**: Указатель на файл, который нужно обработать.
- **`int flags`**: Битовый флаг, указывающий, какие опции были переданы в программу.

---

#### Цикл чтения файла `fgets`

```C
char *fgets(char *str, int n, FILE *stream);
```

- **`str`**: Указатель на буфер, в который будет записана прочитанная строка.
- **`n`**: Максимальное количество символов, которые будут прочитаны (включая завершающий нулевой символ).
- **`stream`**: Указатель на файл, из которого будет производиться чтение.

Используется для чтения файла построчно до тех пор, пока не будет достигнут конец файла (EOF).

---

#### [doc.md](doc.md)
